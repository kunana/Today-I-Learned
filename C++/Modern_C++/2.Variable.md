# 변수
# 변수

1. 모든 변수는 타입을 가지며 , 한번 정해진 타입은 절대 변하지 않는다.

2. 변수 선언 방법은 시작부분에 타입을 적고 그뒤에 변수의 이름을 적는다.
 
4. 선언된 변수는 초기화 또는, 변수목록을 선택적으로 넣을수도 있다.
 
6. Camel case, Pascal case 가 있다.

```cpp
int i1 = 2;    // 줄을 맞춰 가독성을 높인다.
int i2, i3 = 5;
float pi = 3.14159;
double x = -1.5 e6;  // -1500000
double y = -1.5e-6;  // - 0.0000015  
char c1 = 'a', c2 = 35;  
bool cmp = i1 < pi,  //-> true
     happy = true;
```

> ## 내장타입 (Intrinsic Type)

기본 타입은 내장타입 (Intrinsic Type) 이라 한다.

|  <center>이름</center> |  <center>의미</center> 
|:--------|:--------:|--------:|
|**char** | <center>하나의 문자, 매우좁은 범위를 갖는정수 
|**short** | <center>덜 좁은 범위를 갖는 정수   
|**int** | <center>보통 범위 의 정수 
|**long** | <center>넓은 범위 의 정수 
|**long long** | <center>아주 넓은 범위 의 정수
|**float** | <center>단정밀도를 갖는 부동소수점
|**double** | <center>배정밀도를 갖는 부동소수점
|**long double** | <center>큰범위를 갖는 부동소수점 
|**bool** | <center>부울 방식
|**unsigned** | <center>모든 타입의 부호가 없는 버전
|**signed** | <center>모든 타입의 부호가 있는 버전
|
____
1. char 를 포함하는 처음 5개 타입은 아래로 갈수록 범위가 넓어지는 정수이다.

2. 모든 정수 타입은 signed 또는 unsigned 로 규정할 수 있다.

3. 기본값은 signed 이므로 signed로 규정해도 효과가 없다. (선언하지 않았을때는, 컴파일 따라 기본값이 다름)
4. 정수 타입을 unsigned 로 선언하면 음수값을 가지지 못하지만, 양수값을 표현할수 있는 범위가 2배로 넓어진다.
5. 예를 들어 0을 +0 -0 으로 표현하지 않을때 (unsigned), 표현 범위가 1만큼 더 넓어진다.
6. char 타입은 문자와, 좁은 범위의 숫자, 두가지 방식으로 사용할수 있으며, char 는 정말 특이한 아키텍처를 제외하면, 거의 항상 8비트의 길이를 갖는다.  
7. 따라서 char는 -128 ~ 127(signed) 나, 0 ~255 범위의 값을 가질수 있고, 연산을 수행할 수 있다.
8. 8비트에 맞는 코드를 갖는 모든 문자를 나타 낼 수도 있다. 
9. 일반적으로 float 은 32비트, double 은 64비트, long double 80비트이다.
____
#### 주의
`변수를 가능한 늦게 선언하라. 일반적으로 변수를 처음 사용하기 직전에 선언하는 것이 좋고, 가능하다면 초기화 할수 잇는 상태 이전에는 선언 하지 않는 것이 좋다`
___



[`C++11`] 은 변수의 타입을 추론할수 있다. 

예를 들어
```cpp
auto i4 = i3 + 10
```
i4 의 타입은 i3 + 10 타입인 int 와 같다. 타입이 자동으로 정해지지만, 동일하게 유지하며, 무엇이든 int로 변환되고 난 이후에 i4  에 할당한다. 
____
> ## 상수 (Constant)

상수란 불변이라는 속성을 갖는 특별한 변수이다. 

따라서 `상수는 변경할 수 없기 때문에 선언과 동시에 값을 반드시 설정해야한다.`

상수는 컴파일 하는 동안 이미 그 값을 알고 있으며, 이를 통해 다양한 최적화를 할수 있다.

```cpp
const int num1 = 2;
const float num2 = 4;
const float num3;  // 컴파일 에러! 
const char num4 = 6;
```

> ## 리터럴 (Literal)

2, 혹은 3.14 같은 리터럴도 입력 할수 있다. 

간단히 말하자면, 정수는 자릿수에 따라 int, long, unsigned long 타입으로 취급한다.

소수나 지수는 double  타입으로 취급한다.

다른 리터럴 타입은 아래 표에 있는 접미사를 추가 하면된다.

|  <center>리터럴</center> |  <center>타입</center> 
|:--------|:--------:|--------:|
|**2** | <center>int</center>
|**2u** | <center>unsigned </center>
|**2l** |<center>long </center>
|**2ul** |<center>unsigned long </center>
|**2.0** | <center> double </center>
|**2.0f** | <center> float </center>
|**2.0l** | <center> long double </center>
____

대부분은 내장 된 숫자 타입들 사이의 묵시적 변환을 통해 프로그래머가 기대하는 타입으로 값을 설정해 주기 때문에, 리터럴 타입을 명시적(`강제변환`)으로 선언할 필요없다.

그러나 리터럴의 타입에 주목해야 하는 이유는 크게 세가지가 있다.

### 1. 유용함

표준 라이브러리는 복소수를 위한 타입을 제공한다. 여기서 실수부와 허수부의 타입은 사용자가 매개변수화 할 수 있다.

```cpp
std::complex<float> z (12.3, 35.1), z2;
```

그러나 불행하게도 타입 자체와 기본 실수 타입 사이의 연산만 지원한다. ( 그리고 인수들은 여기서 변환 되지않는다.) 

즉 float으로 값을 설정한 z 는 int 나 double 과 곱할수 없다.

```cpp
z2 = 2 * z; // 컴파일 에러! int * float
z3 = 2.0 * z; // 컴파일 에러! double * float
z4 = 2.0f * z; // 정상 float * float

//같은 타입의 float 만 연산이 가능하다.
```

### 2.  애매모호함

함수를 서로 다른 인수 타입으로 오버로딩 했을때, 0과 같은 인수는 애매모호 할수 있지만,

0u 와 같이 한정된 인수는 정확하게 일치하는 타입이 있다.

### 3. 정확함

정확도 문제는 long double 타입으로 작업할 경우 발생한다. 한정되지 않은 리터럴은 double 타입이기 때문에 long double 타입 변수로 할당하기 전에 자릿수를 잃어 버릴수도 있다.

```cpp
// 자릿수를 잃어버릴 것이다.(double타입)
long double third1 = 0.3333333333333333333; 
// 정확함.
long double third2 = 0.3333333333333333333l; 
```
____
> ### 10진수가 아닌수

+ 8진수  -> `0으로 시작하는 정수는 8진수`로 해석한다.

예를 들어

```cpp
int o1 = 042; // 34

int o1 = 089; // 컴파일 에러! 8진수에는 8이나 9가 없음!
```

+ 16진수 리터럴 ->  `0x 또는 0X 라는 접두사`를 붙인다.

```cpp
int h1 = 0x42; //66;
int h2 = 0xfa; //250;

```

[`C++14`]  

+ 0b 또는 0B 라는 접두사를 붙이는 `2진수 리터럴`을 도입했다.

```cpp
int h1 = 0b11111010; //250;
```
[`C++14`]  

+ 길이가 긴 리터럴의 가독성을 향상하기 위해 아포스트로피(‘)로 숫자를 분리할 수 있다.

```cpp
long d = 6'546'687'616'861'129l; 
unsigned long ulx = 0x139'ae3b'2ab0'94f3;
int b = 0b101'1001'0011'1010'1101'1010'0001; 
const long double pi = 3.141'592'653'589'793'238'462l;
```


> ##  문자열 리터럴은 char 배열로 할당한다.

```cpp
+ char s1[] = "Old C style"; //더 좋지 않음
```

차라리 <string> 라이브러리의 string 타입을 사용하는 게 더 낫다.

또한 매우 긴 텍스트는 여러개의 부분 문자열로 분할할 수 있다.
```cpp
std::string s2 = "In C++ better like this";

std::string s2 = "In C++ better like this";
                 "that is too loooooooong";
```

> ##  축소하지 않는 초기화

long 타입의 변수를 큰 숫자로 초기화 한다고 하자.

```cpp
long l2 = 1234567890123;
```

위 숫자는 제대로 동작하며, 대부분의 64비트 플랫폼에서 long의 크기는 64비트이다. 
만약 long 의 크기가 32비트 라면, 위에 있는 값은 너무 크다.

컴파일을 잘 될 것이지만, 앞쪽 비트가 버려지게 된다.

[`c++11`]

c++11 에서는 위와 같은 값이 아키텍쳐에 따라 `축소 되지않는 지 확인하는 초기화`를 도입한다.

`유니폼 초기화` 혹은 `중괄호 초기화`를 사용하면 된다.

아래와 같이 사용하면 컴파일러에서 변수가 이 값을 저장할수 있는지 확인 할것이며, 

```cpp
long l = {1234567890123}; // 타겟 아키텍쳐 따라 확인시켜줌
```

우리에게 값을 초기화 할때 정밀도를 잃지 않는 다는것을 확인 할수 있게 해준다.

반면 암시적 변환으로 인해 `부동소숫점 수를 int로 변환하는 일반 적인 초기화는 할수 있다.`

```cpp
int l = 3.14; // 축소 되지만, 컴파일은 가능
int l2 = {3.14}; // 축소오류 : 소수 부분이 사라지게 된다. 
```

두번째 줄에 있는 새로운 초기화 형태는 암시ㅈㄱ 변환이 부동소수점 수의 소수부를 버리므로, 일반적인 초기화를 막는다.

마찬가지로 음수를 부호가 없는 변수나 상수에 할당하는 동작도 기존의 초기화에서는 허용되지만 새로운 형태에서는 금지된다.

```cpp
unsigned u2 = -3; // 축소되지만 , 컴파일 가능
unsigned u2n = {-3}; // 축소오류 : 음수를 가질수 없는 형태.
float f1 = {3.14}; // 괜찮음
```
3.14 라는 값은 모든 이진 부동 소수점 형식의 절대 정밀도로 나타낼수 없지만, 컴파일러는 3.14에 가장 가까운 값으로 f1 을 설정 할수 있다.



[암시적&묵시적 형변환](C++/Modern_C++//Type_Conversion.md)