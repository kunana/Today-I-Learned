<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


- [소프트웨어 프로젝트 구축](#%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B5%AC%EC%B6%95)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 소프트웨어 프로젝트 구축

대규모 프로젝트의 큰 문제는 이름 충돌이다. 이러한 이유로 매크로 가 이 문제를 어떻게 악화 시키는지 살펴본다. 반대로 네임스페이스가 어떻게 이름 충돌을 해결하는 데 도움이 되는지를 보여줄 것이다.

C++ 소프트웨어 프로젝트에서 파일이 상호 작용하는 방식을 이해하려면 빌드 프로세스( 소스파일로부터 실행파일이 생성되는 방법)를 이해해야 한다. 이절에서는 먼저 빌드 프로새ㅔ스를 다룬다.

이어서 매크로 메커니즘과 다른 언어 기능들을 소개한다.

> ### 전처리기 지시문

전처리에 사용할 수 있는 명령을 소개한다(지시문) 대부분 언어와 무관하므로 최소한으로 사용하고 특히 매크로 사용은 제한 하는것이 좋다.

>1. 매크로

매크로는 매크로 이름을 인수와 함께 텍스트 정의로 확장해 코드를 재사용 하는 오래된 기법이다.
매크로를 사용하면 프로그램에 권한을 부여할 가능성이 많지만 프로그램을 망칠 가능성은 더 커진다. 매크로는 타입 개념 없이 무분벼라게 텍스트를 대체하기 때문에 네임스페이스 , 스코프 또는 다른 언어 기능에 대한 저항력이 있다. 

불행하게도 일부 라이브러리는 major 와 같은 공통 이름을 갖는 매크로를 정의하낟. 우리는 이러한 매크로를 사용하려는 사람들에게 자비를 베풀지 않고 #undef major 와 같은 매크로를 사용해 타협 없이 정의 해제한다.

Visual Studio는 오늘 날에도 min 과 max 라는 매크로를 정의한다. 따라서 /DNOMINMAX로 컴파일해 이 기능을 사용하지 않도록 설정 하는 것이 좋다.

대부분의 매크로는 다른기법 ( 상수, 템플릿, 인라인 함수)로 대체할 수있다.

그러나 만약 정말 대체할 다른 방법을 찾지 못한다면,

___
**<참고>**
매크로이름 -> 매우_긴_보기_좋지_않은_이름을_대문자로 사용하라
___

C++ 는 상수, inline 함수, constexpr 처럼 대체할 수잇는 더 나은 방법을 제공한다.

>2. include

가장 자주 사용하는 헤더는 I/O 헤더이다.

```cpp
#include <iostream>
```

전처리기는 /usr/include, /usr/local/inclue 디렉터리에서 해당 파일을 검색한다. 컴파일러 플래그를 사용해 이 검색 경로에 디렉터리를 추가할 수 있다. 일반적으로 윈도에서는 /I 를 사용하면 된다.

아래와 같이 파일 이름을 큰 따옴표로 쓰면,

```cpp
#include "herberts_math_function.hpp"
```

컴파일러는 일반적으로 현재 디렉터리에서 먼저 검색한 다음 표준 경로에서 검색한다.

이름 충돌을 피하기위해 종종inclue 의 상위 디렉터리를 검색 경로에 추가하고 지시문에서 상대 경로를 사용한다.

```cpp
#include "herberts_includes/math_functions.hpp" 
#include <another_project/more_functions.h>
```

슬래시는 이식성이 뛰어나며 하위 디렉터리가 백 슬래시로 표시 된다는 사실에도 불구하고 윈도에서도 잘 동작한다.

>### 포함방지
간접적인 포함으로 인해 자주 사용하는 헤더 파일이 하나의 번역단위에 여러 번 포함 될 수 있다. 금지된 반복을 피하고 텍스트 확장을 제한하기 위해 소위 **포함 방지(include Guard)**는 첫 번쨰로 포함할 때만 수행 하도록 한다. 이방지는 특정 파일을 포함하는 일반 매크로다.

일반 적인 포함 파일은 다음과 같다.

```cpp
// 작성자: 나 // 라이선스: 읽을 때마다 100달러 지불 
#ifndef HERBERTS_MATH_FUNCTIONS_INCLUDE  //정의되어 있지않으면 발생하는 전처리기
#define HERBERTS_MATH_FUNCTIONS_INCLUDE 
#include <cmath>
 double sine(double x); 
... 
#endif // **HERBERTS_MATH_FUNCTIONS_INCLUDE**
```

따라서 파일의 내용은 포함 방지를 아직 정의하지 않은 경우에만 포함한다. 코드 안에서 더 이상 포함하지 않도록 포함 방지를 정의한다.

모든 매크로와 마찬가지로 프로젝트의 이름뿐만 아니라 직접 또는 간접적으로 포함하는 다른 모든 헤더의 이름도 고유해야한다. 이상적으로 이름은 프로젝트와 파일 이름을 나타내야한다. 또한 , 프로젝트와 관련된 경로 또는 네임스페이스[네임스페이스] 도 포함할 수 있다.

일반적으로 끝에 _INCLUDE 또는 _HEADER 를 붙인다. 포함 방지를 실수로 재사용 하면 여러가지 다양한 오류메시지가 출력 될 수 있다. 경험에 따르면 오류 메시지가 발생하는 악의 근원을 발견 하는데 오랜 시간이 걸릴수 있다. 고급 개발자는 앞서 언급한 정보나 난수 생성기를 사용해 자동으로 생성한다.

편리하게 사용할 수있는 대안으로는 #pragama once 가 있다.

이전 예제를 단순화 하면 다음과 같이된다.

```cpp
// 작성자: 나 
// 라이선스: 읽을 때마다 100달러 지불
 #pragma once  
 #include <cmath> 
 double sine(double x); 
 ...
```

pragma 를 사용하면 이중 포함을 피하는 동작이 컴파일러의 책임이 된다.

> ### 조건부 컴파일

전처리기 지시문 의 사용이 중요하고 또한 필요하다고 느낄수 있는 경우 중 하나는 조건부 컴파일을 제어하는 경우다. 전처리기는 분기를 위해
```
#if , #else , #elif, #endif 
```
지시문을 제공한다.

조건은 비교, 정의나 논리 표현식 검사일 수있다.

> ### #ifdef & #ifndef

```cpp
#if defined(매크로명)
#!if defined(매크로명)
```

정의 검사를 다른 조건과 결합 할때에는 긴 형태가 사용된다.

마찬가지로 #elif는 else 와 if를 합쳐놓은 지시문이다.

우리가 완벽한 세계에 살고 있다면 표준 호환 되면서 이식성 있는 C++ 프로그램만 작성하면 된다.

하지만 실제로 이식성이 없는 라이브러리를 사용해야 하는 경우가 종종있다. 윈도에서만 사용할수 있는 라이브러리, 정화학게는 비주얼 스튜디오에서만 사용할 수 있는 라이브러리가 잇다고 가정해보자. 다른 모든 컴파일러에는 대체 라이브러리가 있다.

플랫폼에 의존하는 구현을 위한 가장 간단한 방법은 다른 컴파일러에 대한 대체 코드조각을 제공하는 방법이다.

```cpp
#ifdef _MSC_VER
	...윈도 코드
#else 
	...리눅스/유닉스 코드
#endif
```

마찬가지로 모든 플랫폼에서 사용할 수없는 새로운 언어 기능, 에를 등어 이동 문법을 사용하려면 조건부 컴파일이 필요하다.

```cpp
#ifdef MY_LIBRARY_WITH_MOVE_SEMANTICS     
... 이동을 통해 무언가를 효율적으로 만든다. 
#else 
... 무언가를 덜 효율적이지만 이식성이 있게 만든다. 
#endif
```

여기서 우리는 이동 문법을 지원할 때 이기능을 사용할 수 있으며 이동문법을 지원하지 ㅇ낳아도 컴파일러로 이식성을 유지할 수있다.

물론 이동 문법을 실제로 사용할 수있을때 만 매크로를 정의하는 신뢰 가능한 도구가 필요하다.

조건부 컴파일은 매우 강력하지만 그만큼 비용이든다

소스 코드 및 테스트의 유지관리가 더 힘들고 오류가 발생하기 쉽다.

이러한 단점은 잘 설계된 캠슐화를 통해 줄어 들수 있으므로 공통 인터페이스를 통해 서로 다른 구현을 사용한다.

> #### 중첩 가능한 주석문

```cpp

#if 0     
... 여기에 나쁜 코드를 작성했다! 언젠가 고칠 것이다. 진지하게. 
#endif 
/* ... */의 장점은 중첩될 수 있다는 점이다.
#if 0     
... 여기서 난센스가 시작된다. 
#if 0     
... 난센스 안에 난센스가 있다. 
#endif     
... 난센스의 피날레 (다행히 무시당했다). 
#endif
```

그럼에도 불구하고 이 기법은 검토해서 사용해야 한다. 만약 프로그램 의 3/4 이 주석 문이라면 심각하게 수정을 고려해야 한다.

[C++의_기본_기능]