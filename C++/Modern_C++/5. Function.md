<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


- [함수](#%ED%95%A8%EC%88%98)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 함수

```cpp
[inline] 리턴_타입 함수_이름 (인수_목록)
{
    //함수본문
}
```

>### 1. 인수

두가지 인수 전달 형태를 구별한다.
+ 값에 의한 호출
+ 레퍼런스에 의한 호출

> ### 값에 의한 호출

함수에 인수를 전달하면 기본적으로 **복사본** 이 만들어 진다.

다음 함수는 x 를 증가 시키지만 함수 외부에서는 이를 알지 못한다.

```cpp
void increment(int x)
{
    x++;
}

int main()
{
    int i = 4;
    increment(i); // i 를 증가시키지 못함
    cout << " i : " << i << endl; 
}
//출력결과는 4
```
increment 함수 내 x++ 연산은 복사된 지역변수 i만 증가 시키고 메인함수 내 i 는 증가 시키지 않는다.

이러한 종류의 인수 전달을 **값에 의한 호출** 또는 **값에 의한 전달**이라고 한다.

> ### 레퍼런스에 의한 호출

함수의 매개 변수를 수정하려면 인수를 레퍼런스로 전달 해야한다.

```cpp
void increment(int& x)
{
    x++;
}
```

이제 변수  i 자체가 증가되어 예상대로 5를 출력 한다.

연산 결과와 같은 임시 변수들은 레퍼런스로 전달할 수 없다.

```cpp
increment(i +9); // 오류! 임시변수는 참조 할수 없다.
```

임시 값을 일부 갖는 함수를 호출 하려면 먼저 변수에 임시 값을 저장하고 이 변수를 함수에 전달해야 한다.

벡터 및 행렬과 같이 더 큰 자료 구조들은 비용이 비싼 복사 연산을 피하고자 거의 항상 레퍼런스에 의한 전달을 한다.

```cpp
//벡터 공간의 원소들에 일종의 '길이' 또는 '크기'를 부여하는 함수
double two_norm(vector& v){...}
```

위와 같은 연산은 인수의 값을 변경해서는 안된다,. 그러나 벡터를 레퍼런스로 전달하면 실수로 덮어쓸 위험이 있다. 벡터의 값이 변하지 않았는지, (그리고 복사되지 않았는지) 확인하기 위해 우리는 이 값을 **상수 레퍼런스** 로 전달한다.

```cpp
double two_norm(const vector& v){...}
```

이 함수에서 인수 v 를 변경하려고 하면 컴파일러에서 오류가 발생한다.

값에 의한 호출과 상수 레퍼런스는 인수가 변하지 않지만 서로 다른 방법으로 동작한다.


+ 값으로 전달하는 인수들은 복사본으로 동작하기 때문에 함수 안에서 변경할 수 있다.
  + `(인수가 제대로 복사되었다고 가정한다. 데이터를 손상시키는 복사 작업이 구현된 사용자 정의 타입은 전달 된 데이터의 무결성을 손상시킬 수 있다.)`

+ const 레퍼런스에서는 전달한 인수로 직접 작업할 수 있지만, 인수를 변경할수 있는 모든 연산을 금지한다. 특히 cinst 레퍼런스 인수는 할당의 좌변에 나타나거나, 다른 함수에 const가 아닌 레퍼런스로 전달할 수 없다.
  + (실제로, 할당의 좌변도 const가 아닌 레퍼런스다.)

상수 레퍼런스는 변경가능한 레퍼런스와 달리 임시변수를 허용한다.

```cpp
alpha = two_norm(v + w);
```

> ### 기본값

인수가 일반적으로 같은 값을 갖는 다면 우리는 이값을 기본값으로 선언할수 있다.

만약 n -  제곱근을 계산하는 함수를 구현하고 싶은데 대부분 제곱근을 계산한다고 가정하면 다음과 같이 작성할 수 있다.

또한 이함수는 하나 또는 두개의 인수로 호출할 수있다.
```cpp
double root (double x, int degree = 2) 
{
    //본문
}
```

**단, 인수목록의 끝에서만 여러개의 기본값을 선언할수 있다.**

기본 값은 매개변수를 추가할 때도 유용하다. 인수목록에 끝에서만 선언하기 때문에 기존에 쓰던 함수를 리팩터링 할 필요가 없다.

> ### 결과 반환

이전 예제에서는 double 나 int 만 반환 했지만, 데이터가 크거나 없는 양극단의 경우를 살펴보자.

1. **큰 데이터 반환하기**

크기가 큰 자료구조의 새값을 계산하는 함수는 매우 까다롭다. 여기서는 옵션만 언급한다.

좋은 소식은 컴파일러가 많은경우에 반환 값의 복사본을 삭제할 만큼 똑똑 하다는 것이다.[2.3.5.3절]

또한 임시데이터에 이동문법을 사용하면 앞서 언급한 생략이 적용할 수 없을때 복사본을 피할수 있다.[이동문법]

고급 라이브러리는 표현식 템플릿이라고 하는 기법으로 크기가 큰 자료구조를 반환하지 않으며, 결과를 저장할 위치를 알 때까지 게산을 지연시킨다 [5.3.2절]

2. **아무것도 반환하지 않기**

각 함수는 문법적으로 반환할 것이 아무것도 없는 경우에도 뭔가를 반환해야 한다. 이 딜레마는 void 라는 타입을 통해 해결할수 있다.

void 는 실제 타입이 아니라 **값반환을 생략할 수 있는 자리표시자(placeholder)** 이다

```cpp
void heavycompute(const vector& x, double eps, vector& y)
{
    for(...)
    {
        if(two)norm(y) < eps)
            return;
    }
}
```

3. **인라인**

함수를 호출할때 드는 비용은 비교적 많다고 할수있다.

레지스터를 저장하고 스택에 인수를 복사해야한다. 

이 오버헤드를 피하ㄱ자, 컴파일러는 함수 호출을 인라인 할수 있다.

함수 호출을 인라인 하면, 해당 부분을 함수에 포함된 연산으로 대체한다.

```
inline double square(double x)
{
    return x * x;
}
```

그러나 컴파일러는 인라인을 수행할 의무가 없다.  반대로 성능 면에서 유리해 보이면 키워드가 없어도 함수를 인라인 할수도 있다. 

[inline_선언]

4. **오버로딩**

함수는 매개변수 선언이 충분히 다르면 같은 이름을 공유할 수 있다.

```cpp
#include <iostream>
#include <cmath>

int divide(int a, int b)
{
    return a / b;
}

float divdie(float a, float b)
{
    return std::floor(a / b);
}

int main()
{
    int x = 5, y = 2;
    float n = 5.0, m = 2.0;
    std::cout << divide(x, y) << std::endl; // int divide
    std::cout << divide(n, m) << std::endl; // float divide
    std::cout << divide(x, m) << std::endl; // 오류: 모호하다. int / float
}
```

여기서는 int와 float 매개변수를 사용해 divide 함수를 두번 정의 했다. divide 함수를 호출하면 컴파일러는 **오버로드 확인**을 수행한다

    1. 인수 타입과 정확히 일치하는 오버로드가 있는가? 있다면 해당 오버로드를 취한다.

    그렇지 않다면

    2. 변환후 일치하는 오버로드가 있는가? 얼마나 있는가?
       + 0개 : 오류
       + 1개 : 해당 오버로드를 취한다.
       + > 1개 오류, 모호한 호출    

오버로드 확인 이 예제에 어떻게 적용된는 지 살펴보자

divide (x, y) 와  divide(n, m) 호출은 정확히 일치하나

divide (x, m)의 경우, 정확하게 일치하는 오버로드가 없고, **암시적 변환** 에 의해 오버로드 할수 있기에 모호하다.

**암시적 변환** 이라는 용어 에는 몇가지 설명이 필요하다.

우리는 이미 숫자 타입이 서로 변환 할수 있음을 확인했다. 이 변환은 예제에서 볼 수 있듯이 암시적 변환이다. 

나중에 사용자 정의 타입을 정의 할때 기존 타입에서 새타입으로, 반대로 새타입에서 기존 타입으로의 변환을 구현할 수있다. 

이러한 변환은 explicit 으로 선언 할수 있으며, 명시적인 변환을 요청 했을 경우에만 적용한다. 함수 인수의 타입이 일치하는 경우에도 적용한다.

더 형식적으로 이야기 하자면, 함수 오버로드는 시그니처가 서로 달라야한다.

C++ 에서 시그니처는 아래와 같이 구성되어있다.
+   함수이름
+   항(arity)라고 하는 인자의 개수
+   (해당 순서대로) 인자의 타입

반대로 **리턴 타입이나 인수 이름만 다른 오버로드는 동일한 시그니처**를 가지며, (금지된) **재정의로 간주한다.**

```cpp
void f(int x){} 
void f(int y){} // 재정의 : 인수 이름이 다름
long f(int x){} // 재정의 : 리턴 타입만 다름
}
```

이름이나 인자의 개수가 다른 함수는 말할 필요도 없이 서로 다른 함수다. 레퍼런스 기호가 있으면 인수 타입이 다른 인수 타입으로 바뀐다 ( 따라서 f(int 와 f(int&)가 공존 할 수있다.))

다음 세 오버로드는 서로 다른 시그니처를 갖는다.

```cpp
void f(int x){}
void f(int& x){}
void f(const int& x){}
```

아래의 코드는 컴파일 되나, f를 호출할때 문제가 발생한다.

```cpp
int i =3;
const int ci = 4;
f(3); // 정수
f(i); // int
f(ci); // const int
```

모든 경우에 대해 가장 일치하는 오버로드는 값 인수를 갖는 첫번째 오버로드의 인수에 레퍼런스 지정자가 있는 인수를 갖는 오버로드 중 하나이므로 위 세 함수 호출 모두 모호하다

레퍼런스와 값 인자를 갖는 오버로드가 혼합되어 있을 경우, 대부분 실패한다. 

따라서 **한 오버로드가 레퍼런스 지정자가 있는 경우, 다른 오버로드의 인수도 레퍼런스 지정자가 있어야 한다.**

우리는 값 인자 오버로드를 생략해 예제에 잇던 모호한 오버로딩 문제를 해결할수 있다.

그러면 f(3)과 f(ci) 는 상수 레퍼런스가 있는 오버로드로  f(i) 가 변수 레퍼런스가 있는 오버로드로 변환된다.

5. main 함수

main 함수의 표준 시그니처는 2가지다

```cpp
int main()
```

```cpp
int main(int argc, char* argv[]) 

//혹은

int main(int argc, char** argv[])
```

**매개변수 argv 는 인수 목록을 포함하고 argc 는 인수 개수를 나타낸다.**

첫번째 인자 (argv[0]) 은 대부분 시스템에서 호출한 실행 파일의 이름이다.

인수를 가지고 놀기위해 argc_argv_test 라는 프로그램을 작성해 보다

```cpp
int main(int argc, char* argv[])
{
    for(int i = 0; i < argc; ++i)
    {
        cout << argv[i] << '\n';
    }
    return 0;
}
```

다음 옵션으로 이 프로그램을 호출하면

`argc_argv_test first second third fourth`

출력 결과는 아래와 같다

    argc_argv_test
    first
    second
    third
    fourth

보다시피 명령의 각 공백은 인수를 분리한다.

main 함수는 프로그램이 올바르게 끝났는지 여부를 나타내는 종료코드로 정수를 반환한다.

0, (<cstdlib> 의 EXIT_SUCCESS 매크로) 이외의 값은 실패를 나타낸다.

main 함수에서 return 문을 생략할 경우, 표준을 준수하게 되는데

이 경우에는 return 0; 를 자동으로 삽입한다.  [세부사항]

