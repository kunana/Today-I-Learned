<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


- [표현식 과 문장](#%ED%91%9C%ED%98%84%EC%8B%9D-%EA%B3%BC-%EB%AC%B8%EC%9E%A5)
    - [2. 조건식](#2-%EC%A1%B0%EA%B1%B4%EC%8B%9D)
    - [3. switch 문](#3-switch-%EB%AC%B8)
    - [4. 반복문](#4-%EB%B0%98%EB%B3%B5%EB%AC%B8)
    - [4.2 for 문](#42-for-%EB%AC%B8)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 표현식 과 문장

> ### 1. 표현식
표현식을 재귀적으로 처음부터 구축해 보자

모든 변수의 이름, 상수, 리터럴은 표현식이다. 

연산자로 결합한 하나 이상의 표현식들은 표현식을 구성한다 
    
`(x + y, x * y + z)`

C++ 에서 할당문은 표현식이다 

`x = y + z`

결과적으로 다른 표현식을 다른 할당문 안에 사용할 수 있다. 

`x2 = x = y + z`

할당문은 오른쪽에서 왼쪽 순서로 수행한다,. 

아래와 같이 입력 및 출력 잡업도 표현식이다.

```cpp
std::cout << "x is " << x << "\n"
```

표현식을 인자로 넣은 함수 호출도 표현식이다. 

`abs(x)`  `abs(x * y ++ z)` 

따라서 `pow(abs(x), y)` 처럼 중첩 할수 있다. 

하지만 함수 호출이 문장이라면 중첩이 불가능 하다는 점을 유의하라

할당이 표현식이므로, 함수의 인자 혹은 I/O 작업에 사용 할 수 있다.

```cpp
print(std::cout << "x is " << x << "\n", "I am a boy");
```

> ###    2. 문장

끝에 세미콜론이 오는 표현식들을 문장이라 한다. 

```cpp
x = y + z;
y = f(x + z) * 3.5;
```


하나의 세미콜론은 빈 문장이다. 중괄호로 둘러싸인 일련의 문장도 문장이다. 이를 **복합문** 이라 한다.

이전에 보았던 변수와 상수 선언도 문장이다. 

> ###    3. 분기문
___
### 1. if 문
___
```cpp
double D = q * q / 4.0 + p * p * p / 27.0;
if (D > 0.0) 
    {
        double z1 = ...;     
        complex<double> z2 = ..., z3 = ...;     
        ... 
    } 
    else if (D == 0.0) 
    {   double z1 = ..., 
        z2 = ..., 
        z3 = ...;
        ... 
    } 
    else 
    {   // D < 0.0
        complex<double> z1 = ..., 
        z2 = ..., 
        z3 = ...;
        ... 
    }
```
___
**<주의>**

공백은 C++ 에서 컴파일 할때 아무런 영향을 주지는 않지만 들여쓰기는 프로그램의 구조를 반영해야 한다.

들여쓰기를 이해하는 에디터들은 자동으로 구조화된 프로그래밍을 하는 데 큰 도움을 준다. 줄을 예상한대로 들여쓰지 않는다면 뭔가 의도한 대로 중첩하고 있지 않을 가능성이 크다.
___

### 2. 조건식
___
```cpp
조건 ? true : false
```
?: 는 표현식이므로 변수를 초기화 하는데 사용할 수 있다.

```cpp
int x = f(a),
    y = x < 0 ? : -x : 2 * x;
```

함수를 호출 할때 조건식을 사용하면 특정 조건에 따라 다른 인자를 손쉽게 호출 할 수 있다.

```cpp
f(a, (X < 0 ? b : C), (y < 0 ? d : e))
```

반면 if 문을 사용해서 위 작업을 수행하려면 꽤나 복잡해진다.
___
### 3. switch 문
___
```cpp
switch(op_code) 
{
    case 0: 
    z = x + y; 
    break;     
    case 1: 
    z = x – y; 
    cout << "compute diff\n"; 
    break;     
    case 2:     
    case 3: 
    z = x * y; 
    break;     
    default: 
    z = x / y; 
}
```

특이한 동작이 있다면 해당 case 에서 break 로 중단하지 않을 경우 다음 case 에 있는 코드도 수행한다.
___
### 4. 반복문
___
4.1 while 문 과 do-while 문

while 문 은 특정 조건을 만족할 동안 안에 있는 내용을 반복한다. 

콜라츠 급수를 구현해보자

![](2019-01-02-14-52-44.png)

오버 플로를 걱정하지 않아도 된다면 while 문을 통해 이 알고리즘을 쉽게 구현할 수있다.

```cpp
int x = 19;
while(x != 1)
{
    cout << x << '\n';
    if(x % 2 == 1) //홀수라면
        x = 3 * x + 1;
    else // 짝수
         x = x / 2;
}
```

if문과 만찬가지로 오직 하나의 문장만 있을때는 반복할 내용을 중괄호 없이 작성할 수 있다.

do - while 반복문은 do 구문에 있는 내용을 적어도 한번은 수행한다.

```cpp
double eps = 0.001;
do{
    cout << "eps = " << eps << '\n' ;
    eps /= 2.0;
}while (eps > 0.0001);
```
___
### 4.2 for 문
___

```cpp
double v[3], w[] = {2, 4, 6}, x[] = {6, 5, 3};

for(int i = 0; i < 3; ++i)
{
    v[i] = w[i] + x[i];
}


for(int i = 0; i < 3; ++i)
{
    std::cout << "v[" << i << "] = " << v[i] << '\n';
}
```

반복문의 시작부분은 세 구성요소로 이루어져 있다.

+ 초기화
+ 반복 조건
+ 반복작업

인덱스를 갖는 대부분의 자료구조는 0부터 시작한다. 

보통 반복 조건에서는 인덱스가 특정 크기보다 작은지를 검사하면, 반복 작업에서는 인덱스를 증가시킨다.

우리는 예제에서 변수 i 를 사전 증가 시켰다.

int 같은 내장타입에서는 i++, ++i 가 별로 중요하지 않지만, 

사용자 정의 탕립의 경우 사루 증가를 사용하면 불필요한 복사가 일어나게 된다. 

[불필요한복사]

초보자들이 자주 하는 실수 중 하나는 조건을

` i <= size(..)`

와 같이 작성하는 것이다.

c++ 에서 인덱스는 0부터 시작하기 때문에 인덱스 

`i == size(..)`

는 이미 범위를 벗어난 생태이다.

또 다른 예로 지수함수의 테일러 급수를 계산할수 있다.

[테일러급수](https://www.wikiwand.com/ko/%ED%85%8C%EC%9D%BC%EB%9F%AC_%EA%B8%89%EC%88%98)

예제에서는 열번째 항까지 구해보기로 하자

```cpp
double x = 2.0, xn = 1.0, exp_x = 1.0;
unsigned long fac = 1;

for(unsigned long n = 1; n <= 10; ++n)
{
    xn *= x;
    fac *= n;
    exp_x += xn / fac;
    std::cout << "e^x is" << exp_x << '\n';
}
```

여기서 0번째 항을 따로 계산하고 1번째 항부터 반복문을 시작하는게 간단하다.

또한 항x^10 / 10! 고려했는지 확인하기 위해 "작거나 같음" 비교 연산자를 사용했다.

C++ 의 for 문은 꽤나 유연하다.

초기화 부분은 임의의 표현식, 또는 변수를 선언하거나 빈 상태로 둘 수 있다.

같은 타입의 변수를 여러 번 선언 할 수도 있다. 

이는 반복조건에 같은 동작을 반복하는 것을 피하기 위함이다.

```cpp
for(int i = xyz.begin(), end = xyz.end(); i < end; ++i)
```

반복조건은 비워두면 항상 true 가 되어 무한 반복문이 된다. 

**C++11**

**범위 기반 for 문** 새로운 문법이 추가되었는데, 이를 통해 반복문을 매우 간결하게 표현 할수 있다. 범위기반 for 문의 자세한 배경은 [반복자] 개념 설명때 설명한다.

```cpp
int prime[] = {2, 3, 5, 7, 11, 13, 17, 19};
for (int i : primes)
    std::cout << i << " " ;
```

**반복문 제어**


반복문을 수행하는 도중에 이탈하는 방법은 두가지가 있다.

+ break
+ continue
  
break 는 반복문을 종료하는 키워드이고, continue 는 현재 반복에 대해서만 끝내고 다음 반복을 이어서 수행하는 키워드다.

**goto**

goto 는 명시적인 점프를 제공한다. 그러나,

goto 를 사용하지마라. 