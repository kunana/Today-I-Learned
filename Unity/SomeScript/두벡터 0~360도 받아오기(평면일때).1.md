
># 평면일때 두벡터 의 각도 계산하기. (두 벡터 를 이용)


> ## 1. FromToRotation 함수 사용 (360도)

### From To의 축이 같다는 전제하에 두벡터의 Z를 가져와서 각도를 구함
```csharp
private void Calculate_Angle_FromToRotation(Vector3 StartPos, Vector3 endPos) //시작점과 끝점에 대한 마우스 포지션
    {
       float result = Quaternion.FromToRotation(Vector3.up, endPos - StartPos).eulerAngles.z;
       print(result);
    }
```
<br>

> ## 2. Atan 사용 (-180 ~ 180도)

```csharp
public static float Calculate_Angle_Atan2(Vector3 from, Vector3 to)
{
    Vector3 v = to - from;
    return Mathf.Atan2(v.y, v.x) * Mathf.Rad2Deg;
}
```
<br>

> ## 3. SignedAngle 사용 (-180 ~ 180도)

### Axis는 transform.forward, -transform.forward로 시계, 반시계 방향을 정할 수 있다.
```csharp
float angle = Vector3.SignedAngle(transform.up, endPos - startPos, -transform.forward);
```

> ## 3. 시작점을 기준으로 한 여러 방향의 축과 끝점의 거리를 비교 (방향)
```csharp
private Sign GetMouseDirection(Vector3 startPos, Vector3 endPos)
    {   
      
       float shortestDistance = Mathf.Infinity; // 가장 짧은 거리
       float distance = 0; // 비교하기 위해 저장할 거리 변수

       distance = Mathf.Abs(((startPos + Vector3.up) - endPos).magnitude); //상
       if (distance < shortestDistance)
       {
           shortestDistance = distance;
       }
       distance = Mathf.Abs(((startPos + -Vector3.up) - endPos).magnitude); // 하
       if (distance < shortestDistance)
       {
           shortestDistance = distance;
       }
       distance = Mathf.Abs(((startPos + Vector3.left) - endPos).magnitude); //좌
       if (distance < shortestDistance)
       {
           shortestDistance = distance;
       }
       distance = Mathf.Abs(((startPos + Vector3.right) - endPos).magnitude); // 우
       if (distance < shortestDistance)
       {
           shortestDistance = distance;
       }
       distance = Mathf.Abs(((startPos + Vector3.foward) - endPos).magnitude); // 앞
       if (distance < shortestDistance)
       {
           shortestDistance = distance;
       }
       distance = Mathf.Abs(((startPos - Vector3.foward) - endPos).magnitude); // 뒤
       if (distance < shortestDistance)
       {
           shortestDistance = distance;
       }

       print(result);
       return result;
    }
    // 대체적으로 비효율적..

```